<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas Outliner Editor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
            overscroll-behavior: none; /* スクロール連鎖を防止 */
        }
        #editor-container {
            position: relative;
            width: 100%;
            height: 100%;
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: text;
        }
        #hidden-textarea {
            position: absolute;
            color: transparent;         /* テキストの色を透明に */
            background-color: transparent; /* 背景色を透明に */
            border: none;               /* 枠線をなくす */
            outline: none;              /* フォーカス時の枠線をなくす */
            caret-color: transparent;   /* カーソル(キャレット)も透明に */
            width: 1px;
            height: 1px;
            overflow: hidden;
            resize: none;
            white-space: pre-wrap;
            -webkit-user-select: none;
            user-select: none;
        }
    </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-gray-100">
    <div id="editor-container" class="w-screen h-screen">
        <textarea id="hidden-textarea" spellcheck="false" autocomplete="off" autocorrect="off" autocapitalize="off"></textarea>
        <canvas id="editor-canvas"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('editor-canvas');
        const ctx = canvas.getContext('2d');
        const hiddenTextarea = document.getElementById('hidden-textarea');

        // --- 設定 ---
        const CONFIG = {
            fontSize: 16,
            fontFamily: 'Menlo, Monaco, "Courier New", monospace',
            lineHeight: 24,
            indentWidth: 24,
            bulletRadius: 2.5,
            lineColor: '#374151', // dark: gray-700
            textColor: '#d1d5db', // dark: gray-300
            cursorColor: '#f87171', // red-400
            selectionColor: 'rgba(251, 146, 60, 0.3)', // orange-400
            caretBlinkRate: 500, // ms
            padding: { top: 10, left: 20 },
        };

        // --- 状態管理 ---
        let state = {
            lines: [
                { text: 'Canvas Outliner Editor', indent: 0, collapsed: false, id: Date.now() },
                { text: '基本的な使い方', indent: 1, collapsed: false, id: Date.now() + 1 },
                { text: 'Tab/Shift+Tabでインデントを変更', indent: 2, collapsed: false, id: Date.now() + 2 },
                { text: 'Ctrl+↑/↓で行を移動', indent: 2, collapsed: false, id: Date.now() + 3 },
                { text: 'Ctrl+Enterで折りたたみ/展開', indent: 2, collapsed: true, id: Date.now() + 4 },
                { text: 'これは折りたたまれた項目です', indent: 3, collapsed: false, id: Date.now() + 5 },
                { text: 'Ctrl+←/→でインデントを変更', indent: 2, collapsed: false, id: Date.now() + 6 },
                { text: 'ショートカット', indent: 1, collapsed: false, id: Date.now() + 7 },
                { text: 'ほとんどの標準的なテキストエディタのショートカットが使えます。', indent: 2, collapsed: false, id: Date.now() + 8 },
                { text: '[角括弧]を入力すると自動補完されます。', indent: 2, collapsed: false, id: Date.now() + 9 },
                { text: 'https://google.com のようなリンクは自動でハイパーリンクになります。', indent: 2, collapsed: false, id: Date.now() + 10 },
                { text: '> 引用もできます。', indent: 2, collapsed: false, id: Date.now() + 11 },
            ],
            cursor: { line: 0, col: 0 },
            selection: { start: null, end: null },
            scrollTop: 0,
            caretVisible: true,
            undoStack: [],
            redoStack: [],
        };
        
        let lastCaretToggle = 0;

        // --- 初期化 ---
        function init() {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('wheel', handleWheel, { passive: false });
            hiddenTextarea.addEventListener('input', handleInput);
            hiddenTextarea.addEventListener('compositionstart', handleCompositionStart);
            hiddenTextarea.addEventListener('compositionend', handleCompositionEnd);
            window.addEventListener('keydown', handleKeyDown);
            
            // フォーカスを確実にセット
            hiddenTextarea.focus();
            updateHiddenTextareaPosition();
            saveState(); // 初期状態を保存
            requestAnimationFrame(gameLoop);
        }

        function resizeCanvas() {
            const dpr = window.devicePixelRatio || 1;
            canvas.width = window.innerWidth * dpr;
            canvas.height = window.innerHeight * dpr;
            canvas.style.width = `${window.innerWidth}px`;
            canvas.style.height = `${window.innerHeight}px`;
            ctx.scale(dpr, dpr);
        }
        
        // --- 描画ループ ---
        function gameLoop(timestamp) {
            update(timestamp);
            draw();
            requestAnimationFrame(gameLoop);
        }

        function update(timestamp) {
             // カーソルの点滅処理
            if (timestamp - lastCaretToggle > CONFIG.caretBlinkRate) {
                state.caretVisible = !state.caretVisible;
                lastCaretToggle = timestamp;
            }
        }

        // --- 描画関連 ---
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.font = `${CONFIG.fontSize}px ${CONFIG.fontFamily}`;

            const visibleLines = getVisibleLines();
            
            drawSelection(visibleLines);

            let y = CONFIG.padding.top - state.scrollTop;
            
            // 階層を示すガイドラインを描画
            drawIndentGuides(visibleLines, y);
            
            // テキストとブレットを描画
            visibleLines.forEach((lineData, i) => {
                const { line, originalIndex } = lineData;
                const x = CONFIG.padding.left + line.indent * CONFIG.indentWidth;
                
                // 行が画面内になければ描画しない
                if (y + CONFIG.lineHeight > 0 && y < canvas.height / (window.devicePixelRatio || 1)) {
                    drawBullet(x, y, line, originalIndex);
                    drawText(x, y, line, originalIndex);
                }

                y += CONFIG.lineHeight;
            });
            
            drawCursor(visibleLines);
        }

        function getVisibleLines() {
            const visible = [];
            let collapsedUnderIndent = -1;
            state.lines.forEach((line, index) => {
                if (collapsedUnderIndent !== -1 && line.indent > collapsedUnderIndent) {
                    return; // 折りたたまれているのでスキップ
                }
                
                if (line.collapsed) {
                    collapsedUnderIndent = line.indent;
                } else {
                    collapsedUnderIndent = -1;
                }
                
                visible.push({ line, originalIndex: index });
            });
            return visible;
        }

        function drawIndentGuides(visibleLines, startY) {
            ctx.strokeStyle = CONFIG.lineColor;
            ctx.lineWidth = 1;
            let y = startY;

            visibleLines.forEach(({line}) => {
                for (let i = 1; i <= line.indent; i++) {
                    const x = CONFIG.padding.left + (i - 0.5) * CONFIG.indentWidth;
                    if (y + CONFIG.lineHeight > 0 && y < canvas.height / (window.devicePixelRatio || 1)) {
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.lineTo(x, y + CONFIG.lineHeight);
                        ctx.stroke();
                    }
                }
                y += CONFIG.lineHeight;
            });
        }

        function drawBullet(x, y, line, lineIndex) {
            const bulletY = y + CONFIG.lineHeight / 2;
            const bulletX = x - CONFIG.indentWidth / 2;
            const hasChildren = (state.lines[lineIndex + 1] && state.lines[lineIndex + 1].indent > line.indent);

            ctx.fillStyle = CONFIG.textColor;
            ctx.beginPath();
            
            if (hasChildren) {
                // 折りたたみ可能な項目
                ctx.moveTo(bulletX - 4, bulletY - (line.collapsed ? 2 : 4));
                ctx.lineTo(bulletX + 4, bulletY);
                ctx.lineTo(bulletX - 4, bulletY + (line.collapsed ? 2 : 4));
                ctx.closePath();
                ctx.fill();
            } else {
                // 通常のブレット
                ctx.arc(bulletX, bulletY, CONFIG.bulletRadius, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        function drawText(x, y, line, lineIndex) {
            const textY = y + (CONFIG.lineHeight - CONFIG.fontSize) / 2 + CONFIG.fontSize - 3;
            const textX = x + 10;
            
            let currentX = textX;
            const text = line.text;

            // シンタックスハイライト
            const linkRegex = /(https?:\/\/[^\s]+)|(\[([^\]]+)\])/g;
            let match;
            let lastIndex = 0;

            while ((match = linkRegex.exec(text)) !== null) {
                // マッチ前の通常テキスト
                const plainText = text.substring(lastIndex, match.index);
                ctx.fillStyle = line.text.startsWith('> ') ? '#9ca3af' : CONFIG.textColor; // 引用
                ctx.fillText(plainText, currentX, textY);
                currentX += ctx.measureText(plainText).width;

                // マッチしたリンク部分
                ctx.fillStyle = '#60a5fa'; // blue-400
                const linkText = match[0];
                const displayText = (lineIndex === state.cursor.line && match[2]) ? match[2] : (match[3] || match[1]);

                ctx.fillText(displayText, currentX, textY);
                const textWidth = ctx.measureText(displayText).width;
                
                // 下線
                ctx.beginPath();
                ctx.moveTo(currentX, textY + 2);
                ctx.lineTo(currentX + textWidth, textY + 2);
                ctx.strokeStyle = '#60a5fa';
                ctx.stroke();
                
                currentX += textWidth;
                lastIndex = match.index + linkText.length;
            }

            // 残りの通常テキスト
            if (lastIndex < text.length) {
                const remainingText = text.substring(lastIndex);
                ctx.fillStyle = line.text.startsWith('> ') ? '#9ca3af' : CONFIG.textColor; // 引用
                ctx.fillText(remainingText, currentX, textY);
            }
        }
        
        function drawCursor(visibleLines) {
            if (!state.caretVisible) return;
            
            const visibleLineIndex = visibleLines.findIndex(l => l.originalIndex === state.cursor.line);
            if (visibleLineIndex === -1) return; // カーソル行が非表示

            const line = state.lines[state.cursor.line];
            const y = CONFIG.padding.top - state.scrollTop + visibleLineIndex * CONFIG.lineHeight;

            // 画面外なら描画しない
            if (y + CONFIG.lineHeight < 0 || y > canvas.height / (window.devicePixelRatio || 1)) return;

            const preCursorText = line.text.substring(0, state.cursor.col);
            const x = CONFIG.padding.left + line.indent * CONFIG.indentWidth + 10 + ctx.measureText(preCursorText).width;

            ctx.fillStyle = CONFIG.cursorColor;
            ctx.fillRect(x, y + 2, 2, CONFIG.lineHeight - 4);
        }

        function drawSelection(visibleLines) {
            if (!state.selection.start) return;

            const { start, end } = getNormalizedSelection();
            if (!start || !end) return;

            for (let i = start.line; i <= end.line; i++) {
                const currentLine = state.lines[i];
                if (!currentLine) continue;

                const visibleLineIndex = visibleLines.findIndex(l => l.originalIndex === i);
                if (visibleLineIndex === -1) continue; // 選択範囲が非表示

                const y = CONFIG.padding.top - state.scrollTop + visibleLineIndex * CONFIG.lineHeight;

                const startCol = (i === start.line) ? start.col : 0;
                const endCol = (i === end.line) ? end.col : currentLine.text.length;

                const prefix = currentLine.text.substring(0, startCol);
                const selectedText = currentLine.text.substring(startCol, endCol);

                const x = CONFIG.padding.left + currentLine.indent * CONFIG.indentWidth + 10 + ctx.measureText(prefix).width;
                const width = ctx.measureText(selectedText).width;

                ctx.fillStyle = CONFIG.selectionColor;
                ctx.fillRect(x, y, width, CONFIG.lineHeight);
            }
        }
        
        function updateHiddenTextareaPosition() {
            const visibleLines = getVisibleLines();
            const visibleLineIndex = visibleLines.findIndex(l => l.originalIndex === state.cursor.line);

            if (visibleLineIndex === -1) {
                // カーソルが非表示の場合はtextareaを画面外に移動
                hiddenTextarea.style.top = `-9999px`;
                hiddenTextarea.style.left = `-9999px`;
                return;
            }
            
            const line = state.lines[state.cursor.line];
            const y = CONFIG.padding.top - state.scrollTop + visibleLineIndex * CONFIG.lineHeight;
            const preCursorText = line.text.substring(0, state.cursor.col);
            const x = CONFIG.padding.left + line.indent * CONFIG.indentWidth + 10 + ctx.measureText(preCursorText).width;

            hiddenTextarea.style.left = `${x}px`;
            hiddenTextarea.style.top = `${y}px`;
        }

        // --- イベントハンドラ ---
        function handleMouseDown(e) {
            hiddenTextarea.focus();
            const { line: lineIndex, col } = getCoordsFromMouseEvent(e);

            const visibleLines = getVisibleLines();
            if (lineIndex >= visibleLines.length) {
                // ファイルの末尾より下をクリック
                const lastLineIndex = state.lines.length - 1;
                state.cursor.line = lastLineIndex;
                state.cursor.col = state.lines[lastLineIndex].text.length;
                state.selection = { start: null, end: null };
                updateHiddenTextareaPosition();
                return;
            };

            const originalIndex = visibleLines[lineIndex].originalIndex;
            state.cursor.line = originalIndex;
            state.cursor.col = col;

            // クリック位置がブレットの近くだったら折りたたみ
            const line = state.lines[originalIndex];
            const bulletX = CONFIG.padding.left + (line.indent - 0.5) * CONFIG.indentWidth;
            if (Math.abs(e.offsetX - bulletX) < CONFIG.indentWidth/2) {
                 toggleCollapse(originalIndex);
            }
            
            state.selection.start = { ...state.cursor };
            state.selection.end = null;
            updateHiddenTextareaPosition();
            
            canvas.addEventListener('mousemove', handleMouseMove);
            window.addEventListener('mouseup', handleMouseUp, { once: true });
        }
        
        function handleMouseMove(e) {
            const { line: lineIndex, col } = getCoordsFromMouseEvent(e);
            const visibleLines = getVisibleLines();
             if (lineIndex >= visibleLines.length) return;
            const originalIndex = visibleLines[lineIndex].originalIndex;
            
            state.cursor.line = originalIndex;
            state.cursor.col = col;
            state.selection.end = { ...state.cursor };
            updateHiddenTextareaPosition();
        }

        function handleMouseUp(e) {
            canvas.removeEventListener('mousemove', handleMouseMove);
             if (state.selection.start && state.selection.end && 
                state.selection.start.line === state.selection.end.line &&
                state.selection.start.col === state.selection.end.col) {
                state.selection = { start: null, end: null };
            }
        }

        function handleWheel(e) {
            e.preventDefault();
            state.scrollTop += e.deltaY;
            const maxScroll = Math.max(0, getVisibleLines().length * CONFIG.lineHeight - (canvas.height / (window.devicePixelRatio||1)) + CONFIG.padding.top*2);
            state.scrollTop = Math.max(0, Math.min(state.scrollTop, maxScroll));
        }

        function handleInput(e) {
            const text = hiddenTextarea.value;
            hiddenTextarea.value = '';
            if (text === '') return;

            if (state.selection.start) {
                deleteSelection();
            }

            const line = state.lines[state.cursor.line];
            const newText = line.text.slice(0, state.cursor.col) + text + line.text.slice(state.cursor.col);
            line.text = newText;
            state.cursor.col += text.length;

            updateHiddenTextareaPosition();
            saveState();
        }

        let isComposing = false;

        function handleCompositionStart(e) {
            isComposing = true;
        }

        function handleCompositionEnd(e) {
            isComposing = false;
        }

        function handleKeyDown(e) {
            // IME入力中は特定のキー以外は処理しない
            if (isComposing && e.key !== 'Enter' && e.key !== 'Backspace' && e.key !== 'Escape') {
                return;
            }

            let handled = false;
            const hasSelection = !!state.selection.start;

            // --- アウトライナー操作（Ctrlキーが必要） ---
            if (e.ctrlKey && !e.altKey) {
                switch (e.key) {
                    case 'ArrowUp': moveLine(-1); handled = true; break;
                    case 'ArrowDown': moveLine(1); handled = true; break;
                    case 'ArrowLeft': changeIndentSelection(-1); handled = true; break;
                    case 'ArrowRight': changeIndentSelection(1); handled = true; break;
                    case 'Enter': toggleCollapse(state.cursor.line); handled = true; break;
                    case 'z': undo(); handled = true; break;
                    case 'y': redo(); handled = true; break;
                    case 'Z': redo(); handled = true; break; // Ctrl+Shift+Z
                }
            }
            // --- Shiftキー操作 ---
            else if (e.shiftKey && !e.ctrlKey && !e.altKey) {
                switch (e.key) {
                    case 'Tab': changeIndentSelection(-1); handled = true; break;
                    case 'Enter':
                        insertText('\n');
                        state.lines[state.cursor.line].indent = 0;
                        saveState();
                        handled = true;
                        break;
                }
            }
            // --- 通常の操作 ---
            else if (!e.ctrlKey && !e.altKey) {
                switch (e.key) {
                    case 'Tab': changeIndentSelection(1); handled = true; break;
                    case 'Enter':
                        if (hasSelection) deleteSelection();
                        insertText('\n');
                        saveState();
                        handled = true;
                        break;
                    case 'Backspace':
                        if(hasSelection) {
                            deleteSelection();
                        } else if (state.cursor.col === 0 && state.cursor.line > 0) {
                            // 行頭でバックスペース: 行を結合
                            const prevLine = state.lines[state.cursor.line - 1];
                            const currentLine = state.lines[state.cursor.line];
                            const newCol = prevLine.text.length;
                            prevLine.text += currentLine.text;
                            state.lines.splice(state.cursor.line, 1);
                            state.cursor.line--;
                            state.cursor.col = newCol;
                            saveState();
                        } else if (state.cursor.col > 0) {
                            const line = state.lines[state.cursor.line];
                            line.text = line.text.slice(0, state.cursor.col - 1) + line.text.slice(state.cursor.col);
                            state.cursor.col--;
                            saveState();
                        }
                        handled = true;
                        break;
                    case 'Delete':
                        if(hasSelection) {
                            deleteSelection();
                        } else {
                            const line = state.lines[state.cursor.line];
                            if (state.cursor.col < line.text.length) {
                                line.text = line.text.slice(0, state.cursor.col) + line.text.slice(state.cursor.col + 1);
                                saveState();
                            } else if (state.cursor.line < state.lines.length - 1) {
                                // 行末でデリート: 次の行を結合
                                const nextLine = state.lines[state.cursor.line + 1];
                                line.text += nextLine.text;
                                state.lines.splice(state.cursor.line + 1, 1);
                                saveState();
                            }
                        }
                        handled = true;
                        break;
                    // --- カーソル移動 ---
                    case 'ArrowLeft': moveCursor(-1, 0, e.shiftKey); handled = true; break;
                    case 'ArrowRight': moveCursor(1, 0, e.shiftKey); handled = true; break;
                    case 'ArrowUp': moveCursor(0, -1, e.shiftKey); handled = true; break;
                    case 'ArrowDown': moveCursor(0, 1, e.shiftKey); handled = true; break;
                    case 'Home': moveCursorToLineBoundary('start', e.shiftKey); handled = true; break;
                    case 'End': moveCursorToLineBoundary('end', e.shiftKey); handled = true; break;
                    // --- 特殊入力 ---
                    case '[':
                        if (hasSelection) deleteSelection();
                        insertText('[]');
                        state.cursor.col--;
                        saveState();
                        handled = true;
                        break;
                }
            }

            if (handled) {
                e.preventDefault();
                updateHiddenTextareaPosition();
                scrollToCursor();
            }
        }
        
        // --- ユーティリティ & ロジック ---
        function getCoordsFromMouseEvent(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const visibleLines = getVisibleLines();
            const lineIndex = Math.floor((y + state.scrollTop - CONFIG.padding.top) / CONFIG.lineHeight);
            const clampedLineIndex = Math.max(0, Math.min(visibleLines.length - 1, lineIndex));
            
            if (clampedLineIndex >= visibleLines.length) {
                return { line: visibleLines.length, col: 0 };
            }

            const { line } = visibleLines[clampedLineIndex];
            const lineXStart = CONFIG.padding.left + line.indent * CONFIG.indentWidth + 10;
            
            let col = 0;
            let textWidth = 0;
            for (let i = 0; i < line.text.length; i++) {
                const charWidth = ctx.measureText(line.text[i]).width;
                if (x < lineXStart + textWidth + charWidth / 2) {
                    break;
                }
                textWidth += charWidth;
                col++;
            }
            return { line: clampedLineIndex, col: col };
        }

        function insertText(text) {
            const { line, col } = state.cursor;
            if (text === '\n') {
                const currentLine = state.lines[line];
                const textAfterCursor = currentLine.text.slice(col);
                currentLine.text = currentLine.text.slice(0, col);
                state.lines.splice(line + 1, 0, {
                    text: textAfterCursor,
                    indent: currentLine.indent,
                    collapsed: false,
                    id: Date.now()
                });
                state.cursor.line++;
                state.cursor.col = 0;
            } else {
                const currentLine = state.lines[line];
                currentLine.text = currentLine.text.slice(0, col) + text + currentLine.text.slice(col);
                state.cursor.col += text.length;
            }
        }
        
        function moveLine(direction) {
            const { line } = state.cursor;
            const targetLine = line + direction;
            if (targetLine < 0 || targetLine >= state.lines.length) return;

            // 親を越えて移動しないように制御
            if(direction === -1 && targetLine > 0) {
                if (state.lines[targetLine].indent < state.lines[line].indent) return;
            }
            if(direction === 1 && targetLine < state.lines.length) {
                if (state.lines[targetLine].indent > state.lines[line].indent) return;
            }
            
            const [movedLine] = state.lines.splice(line, 1);
            state.lines.splice(targetLine, 0, movedLine);
            state.cursor.line = targetLine;
            saveState();
        }

        function changeIndent(lineIndex, direction) {
            const line = state.lines[lineIndex];
            if (!line) return;
            const newIndent = line.indent + direction;
            
            // インデントは0以上で、親より深くはできない
            const parentIndent = findParentIndent(lineIndex);
            line.indent = Math.max(0, Math.min(newIndent, parentIndent + 1));
        }

        function changeIndentSelection(direction) {
            if (state.selection.start) {
                const { start, end } = getNormalizedSelection();
                for (let i = start.line; i <= end.line; i++) {
                    changeIndent(i, direction);
                }
            } else {
                changeIndent(state.cursor.line, direction);
            }
            saveState();
        }

        function findParentIndent(lineIndex) {
            let parentIndent = -1;
            for (let i = lineIndex - 1; i >= 0; i--) {
                if (state.lines[i].indent < state.lines[lineIndex].indent) {
                    parentIndent = state.lines[i].indent;
                    break;
                }
            }
            return parentIndent;
        }
        
        function toggleCollapse(lineIndex) {
            const line = state.lines[lineIndex];
            if (!line) return;
            const hasChildren = (state.lines[lineIndex + 1] && state.lines[lineIndex + 1].indent > line.indent);
            if(hasChildren) {
                line.collapsed = !line.collapsed;
            }
        }

        function moveCursor(colDelta, lineDelta, isSelecting) {
            if (!isSelecting) {
                state.selection = { start: null, end: null };
            } else if (!state.selection.start) {
                state.selection.start = { ...state.cursor };
            }

            const visibleLines = getVisibleLines();
            const currentVisibleIndex = visibleLines.findIndex(l => l.originalIndex === state.cursor.line);
            
            if (lineDelta !== 0) {
                const newVisibleIndex = Math.max(0, Math.min(visibleLines.length - 1, currentVisibleIndex + lineDelta));
                state.cursor.line = visibleLines[newVisibleIndex].originalIndex;
                const lineLen = state.lines[state.cursor.line].text.length;
                state.cursor.col = Math.min(state.cursor.col, lineLen);
            } else if (colDelta !== 0) {
                state.cursor.col += colDelta;
                if (state.cursor.col < 0) {
                    if(currentVisibleIndex > 0) {
                        const newVisibleIndex = currentVisibleIndex - 1;
                        state.cursor.line = visibleLines[newVisibleIndex].originalIndex;
                        state.cursor.col = state.lines[state.cursor.line].text.length;
                    } else {
                        state.cursor.col = 0;
                    }
                } else if (state.cursor.col > state.lines[state.cursor.line].text.length) {
                    if (currentVisibleIndex < visibleLines.length - 1) {
                        const newVisibleIndex = currentVisibleIndex + 1;
                        state.cursor.line = visibleLines[newVisibleIndex].originalIndex;
                        state.cursor.col = 0;
                    } else {
                        state.cursor.col = state.lines[state.cursor.line].text.length;
                    }
                }
            }

            if (isSelecting) {
                state.selection.end = { ...state.cursor };
            }
        }

        function moveCursorToLineBoundary(boundary, isSelecting) {
            if (!isSelecting) {
                state.selection = { start: null, end: null };
            } else if (!state.selection.start) {
                state.selection.start = { ...state.cursor };
            }
            state.cursor.col = (boundary === 'start') ? 0 : state.lines[state.cursor.line].text.length;
            if (isSelecting) {
                state.selection.end = { ...state.cursor };
            }
        }

        function getNormalizedSelection() {
            if (!state.selection.start || !state.selection.end) {
                return { start: state.selection.start, end: state.selection.start };
            }
            const { start, end } = state.selection;
            if (start.line > end.line || (start.line === end.line && start.col > end.col)) {
                return { start: end, end: start };
            }
            return { start, end };
        }

        function deleteSelection() {
            if (!state.selection.start) return;
            const { start, end } = getNormalizedSelection();
            if (!start) return;
            
            const endLine = state.lines[end.line];
            const startLine = state.lines[start.line];
            
            const textAfter = endLine.text.substring(end.col);
            startLine.text = startLine.text.substring(0, start.col) + textAfter;

            // 間の行を削除
            state.lines.splice(start.line + 1, end.line - start.line);
            
            state.cursor = { ...start };
            state.selection = { start: null, end: null };
            updateHiddenTextareaPosition();
            saveState();
        }
        
        function scrollToCursor() {
            const visibleLines = getVisibleLines();
            const visibleLineIndex = visibleLines.findIndex(l => l.originalIndex === state.cursor.line);
            if (visibleLineIndex === -1) return;

            const cursorY = visibleLineIndex * CONFIG.lineHeight;
            const viewHeight = canvas.height / (window.devicePixelRatio || 1) - CONFIG.padding.top;

            if (cursorY < state.scrollTop) {
                state.scrollTop = cursorY;
            } else if (cursorY + CONFIG.lineHeight > state.scrollTop + viewHeight) {
                state.scrollTop = cursorY + CONFIG.lineHeight - viewHeight;
            }
        }
        
        // --- Undo/Redo ---
        function saveState() {
             // 状態をJSON文字列に変換して保存。IDは比較から除外
            const currentState = JSON.stringify(state.lines, (key, value) => key === 'id' ? undefined : value);
            const lastState = state.undoStack.length > 0 ? state.undoStack[state.undoStack.length - 1] : null;

            if (currentState !== lastState) {
                state.undoStack.push(currentState);
                state.redoStack = []; // 新しい操作が行われたらredoスタックはクリア
            }
        }

        function undo() {
            if (state.undoStack.length <= 1) return; // 初期状態は残す
            const lastState = state.undoStack.pop();
            state.redoStack.push(lastState);
            const prevState = JSON.parse(state.undoStack[state.undoStack.length-1]);
            state.lines = restoreIds(prevState, state.lines);
        }

        function redo() {
            if (state.redoStack.length === 0) return;
            const nextState = JSON.parse(state.redoStack.pop());
            state.undoStack.push(JSON.stringify(nextState, (key, value) => key === 'id' ? undefined : value));
            state.lines = restoreIds(nextState, state.lines);
        }
        
        // undo/redo時にIDを復元するヘルパー
        function restoreIds(newLines, oldLines) {
            const oldLinesMap = new Map(oldLines.map(l => [l.text, l.id]));
            return newLines.map(line => ({
                ...line,
                id: oldLinesMap.get(line.text) || Date.now()
            }));
        }

        // --- 実行 ---
        init();
    </script>
</body>
</html>

